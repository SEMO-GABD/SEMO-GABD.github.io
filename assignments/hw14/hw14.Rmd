---
title: "HW 10: Maps"
subtitle: "Graphical Analysis of Biological Data"
output:
  pdf_document: default
  html_document:
    df_print: paged
    toc: yes
urlcolor: blue
editor_options: 
  chunk_output_type: inline
---

```{r include=FALSE}
knitr::opts_chunk$set(include = TRUE, eval = TRUE, echo=TRUE, message=FALSE)
```

By the end of this assignment, you should demonstrate an ability to 

- create outline and filled maps at different scales,
- obtain data from external databases, and
- plot sample locations and distributions on the maps.

Click on any blue text to visit the external website.

This assignment has three parts. 

**Note:** If you cannot get your code to run, open a new issue in the [public discussion forum,](https://github.com/SEMO-GABD/public_discussion), and describe the problem. Include the code that is not working and also tell us what you have tried.

## Preparation

- No reading, no cheatsheets. Just pure mapping pleasure.

- Open your `.Rproj` project file in RStudio.

- Right-click and save these files to your `data` folder.

    - [bears.csv](https://github.com/SEMO-GABD/semo-gabd.github.io/raw/master/assignments/hw10/bears.csv)
    - [bigfoot.csv](https://github.com/SEMO-GABD/semo-gabd.github.io/raw/master/assignments/hw10/bigfoot.csv)
    - [blennies.csv](https://github.com/SEMO-GABD/semo-gabd.github.io/raw/master/assignments/hw10/blennies.csv)
    
- Create an `hw10` folder inside the same folder as your project file.

- Create a new notebook file and save it as `<lastname>_hw10.Rmd` inside your `hw10` folder.

- Add the YAML header as usual.

- Change the Knit directory to "Project Directory".

- Install these packages. **Do not install packages in a code chunk. Run the code in the console or `Tools > Install Packages...`** Including it in a code chunk would try to install the package every time you run the code.

    - `maptools`
    - `maps`
    - `map_data`
    - `rgeos`
    - `sp`
    - `ggmap`: Run `devtools::install_github("dkahle/ggmap")` in the console. Do not install the cran version. 
    - `raster`
    - `marmap`

- Load these libraries, in the order shown. `tidyverse` must be loaded after `raster` so you can use its `select()` function. **Note:** Do not load all of the packages you downloaded. Some, like `raster` and `sp` will be accessed when needed by some functions.

```{r}
library(raster)
library(tidyverse)
library(ggthemes)
library(patchwork)
library(maptools)
library(ggmap)
library(marmap)

```

- Commit early. Commit often.  Push regularly.

- This assignment is part tutorial and part assignment I will give you an example, which you *must* run, and then you will do something similar as instructed. *Read the instructions carefully*.

***

An important part of data visualization is not showing your data but showing were your data are from. You might need to show your sampling locations, the distribution of species, or demographic data for a population of people. You will do all of these in this assignment.


## Part 1: Outline maps

Outline maps show outlines of regions of interest, such as the state boundaries of the U.S. states or the county boundaries of Missouri. In some cases, one or more regions might be filled to draw attention to a particular area.

### Example: States and counties

I used this code to make a map for a colleague and her graduate student. The  map is an outline map of the U.S. with Missouri filled in black and three other stated filled in gray. The figure was used for a new distributional record for a species of ant.  

This example requires `tidyverse`, `ggthemes`, `maptools`, and `patchwork`. `maptools` accesses the `maps` package, which is a database of world countries, states, and U.S. county maps. `map_data` is a `ggplot2` function that accesses specific maps from the `maps` database. 


#### U.S. map

I used `map_data` and also `subset` to access specific regions (states, in this case) and store the results in three data frames.

```{r}
# Outline of the 48 contiguous states
usa <- map_data(map = "state") # Tidyverse or ggplot2 must be loaded

# Outline of just Missouri
us_missouri <- map_data(map = "state",
                        region = "missouri")

# Outline of Alabama, Florida, Mississippi, and North Carolina
us_other <- subset(x = usa, 
                   subset = region %in% c("alabama",
                                          "florida",
                                          "mississippi",
                                          "north carolina"))
```

The `usa` dataframe contains outlines of the 48 contiguous states. You can run `str(usa)` to see the structure or `head(usa)` to see the first few rows of the data. `us_missouri` contains the outline for the state of Missouri. `us_other` is a subset of the `usa` data set, containing outlines for the four states listed. **Note:** the region (state) names are lower case.

```{r}
# You do not have to include this step in your code.
str(usa)
```

The map data are pairs of sequential points, along with an `order` variable. The data are similar to  [connect the dots](https://en.wikipedia.org/wiki/Connect_the_dots) pictures you might have drawn as a child. The numbered points specify the order of connection. Here, the points of the map data are specified by `long` (longitude) and `lat` (latitude). The points are connected in order by a `geom_ploygon` layer.

I built the map in this example one layer at a time to show you the steps. When the time comes, you can plot it all in a single code chunk, like the final step of this example. I built the map up from the bottom layer, overlaying other layers on top. I plotted the outline of the 48 states last so that the state boundaries overlay everything else. 

The first layer has the four non-Missouri states. The species of ant was known previously from these four states. The are filled with gray to highlight them without emphasizing them. You can recognize the states but they are distorted. We will fix the distortion at the very end.

```{r}
ggplot() + 
  geom_polygon(data = us_other, 
               aes(x = long, 
                   y = lat, 
                   group = group), 
               fill = "gray")
```

I added Missouri, filled with black to emphasize it over the other four states.

```{r}
 ggplot() + 
  geom_polygon(data = us_other, 
               aes(x = long, 
                   y = lat, 
                   group = group), 
               fill = "gray") +
  geom_polygon(data = us_missouri, 
               aes(x = long, y = lat, 
                   group = group), 
               fill = "black")
```

Then I added the outline of all 48 states.

```{r}
ggplot() + 
  geom_polygon(data = us_other, 
               aes(x = long, 
                   y = lat, 
                   group = group), 
               fill = "gray") +
  geom_polygon(data = us_missouri, 
               aes(x = long, y = lat, 
                   group = group), 
               fill = "black") +
  geom_polygon(data = usa, 
               aes(x=long, 
                   y = lat, 
                   group = group), 
               fill = NA, 
               color = "black")
```

The map is still distorted and it has the default `theme_gray`. I replaced the default theme with `theme_map()` from the `ggthemes` package. I also added a `coord_fixed` layer with a value of `1.3`, which sets a fixed ratio for longitude and latitude. The longitude is fixed at 1.3 times longer than latitude. Coordinates for maps can be set using more accurate methods but `coord_fixed()` is OK for a map like this. I saved this plot to `us_map` for later plotting with `patchwork`.

```{r}
# Add the filled states first so that the black outlines of all
# states are overlaid on top.
us_map <- ggplot() + 
  geom_polygon(data = us_other, 
               aes(x = long, 
                   y = lat, 
                   group = group), 
               fill = "gray") +
  geom_polygon(data = us_missouri, 
               aes(x = long, y = lat, 
                   group = group), 
               fill = "black") +
  geom_polygon(data = usa, 
               aes(x=long, 
                   y = lat, 
                   group = group), 
               fill = NA, 
               color = "black") + 
  theme_map() +
  coord_fixed(1.3)

us_map
```

#### Missouri map

I then built the Missouri map, highlighting Scott County to show the county where the ant species was collected for the first time ever. I used the same steps as above. I created two objects, one with the polygons for all Missouri counties and one with just the the Scott County polygon. I add the Scott County layer first, then the outline of all the counties. We will do this all in a single chunk.

```{r}
missouri <- map_data("county", "missouri")
mo_scott <- subset(missouri, subregion %in% c("scott"))

mo_map <- ggplot() + 
  geom_polygon(data = missouri, aes(x=long, y = lat, group = group), fill = NA, color = "black") + 
  geom_polygon(data = mo_scott, aes(x = long, y = lat, group = group), fill = "black") +
  theme_map() +
  coord_fixed(1.3)

mo_map
```

I now had a `us_map` object and a `mo_map` object. The final step was to put them side-by-side using the `patchwork` package. I used `ncol = 2` but you could also use `nrow = 1`. The `widths` argument specifies how wide each column should be. I tried several values, deciding finally that the left column with the U.S. map should be 1.5 times wider than the right column with the Missouri map.

```{r}
us_map + mo_map + plot_layout(ncol = 2, widths = c(1.5,1))
```

**Stage, commit, and push.**

### Outline maps: your turn.

Your goal is to make an outline map similar to the above example, but with the following requirements.

- The U.S. map should highlight in black the state of your birth.

- The state map should highlight in black the county of your birth.

- The state map should also show in gray two additional counties, chosen 
based on the initials of your first, middle and last names, assuming you have a middle name and are not a famous [Brazilian football player](https://slate.com/news-and-politics/2006/06/how-brazilian-soccer-players-get-their-names.html). 

For the non-birth counties, pick two county names that correspond with some combination of initials from your first, middle, and last names. For example, I was born in Missouri. In addition to my birth county (St. Louis), I could choose

- Macon and Schuyler,
- Madison and Taney,
- Shelby and Texas, or 
- any other combination of counties that begin with M, S, or T. 

If one of your names begins with a letter that does not match a county in your state (e.g., Ellen or Zachary would not match in Missouri), use the second letter of that name (e.g., L or A for Ellen and Zachary). 

Wikipedia has [lists of counties for each state](https://en.wikipedia.org/wiki/List_of_counties_by_U.S._state_and_territory). 

## Part 2: Dot distribution maps

### Example: Distribution of *Gigantopithecus* and *Ursus*

Dot distribution maps show locations where a species has been sampled. This example is based on a publication from [Lozier et al. 2009](https://onlinelibrary.wiley.com/doi/full/10.1111/j.1365-2699.2009.02152.x). They used [ecological niche modeling](https://pdfs.semanticscholar.org/e98a/80aeec9ab38373397aa11109572abbb77ce4.pdf) to predict the distribution of Bigfoot. Srsly. 

The Bigfoot data were used to make some points about potential pitfalls of the technique, while also showing how well the "niche" of Bigfoot matches the "niche" of black bears [*Ursus americanus*](https://en.wikipedia.org/wiki/American_black_bear).

The bigfoot data were obtained from the [Bigfoot Field Researchers Organization.](http://www.bfro.net/news/google_earth.asp) Srsly. Only [Class A](http://www.bfro.net/gdb/classify.asp) sightings were used. (I still have *some* standards.) The black bear data were obtained from the [Global Biodiversity Information Facility.](https://www.gbif.org)


If you haven't already, right-click and save [bigfoot.csv](https://github.com/SEMO-GABD/semo-gabd.github.io/raw/master/assignments/hw10/bigfoot.csv) and [bears.csv](https://github.com/SEMO-GABD/semo-gabd.github.io/raw/master/assignments/hw10/bears.csv) to your `data` folder.

This example uses the following packages. If you loaded them for Part 1, then you do not have to load them now unless you quit and have now returned to continue working.

```{r eval = FALSE}
library(raster) # Load before tidyverse.
library(tidyverse)
library(ggthemes)
library(ggmap)
```

First, define some global vars that restricts the data to minimum and maximum latitudes and longitudes. We will also set the seed used by the random number generator.

**Important:** Software like R can generate "random" numbers but they are [pseudorandom numbers](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) that only approximate random numbers. Pseudorandom numbers are generated from a "seed", usually based on the computer's internal clock. However, if the seed is set to a fixed number, the "random" can be accurately replicated.

Setting the seed is necessary for reproducibility. Here, I used R's `setseed()` function so that my "random" sampling of bigfoot data from a much larger data set is reproducible. I used a smaller subset of data to keep the map from being too overcrowded with points. Any number can be used for the seed. I used a childhood phone number. If you use the same number, you will get the same results as me.

```{r}
# Global vars -------------------------------------------------------------

# Restrict the map to the western US.
min_long <- -126
max_long <- -104
min_lat  <-   31
max_lat  <-   50

set.seed(9618973)
```

Load the Bigfoot data.  The Bigfoot data has the longitude and latitude for "observations" across North America. The data set is large so I used the `sample()` function to "randomly" sample 300 records. I will get the same 300 records with every sample, as long as I do not change the seed. If I change the seed, then the 300 records will not all be the same.

I filtered the data to restrict the distribution to the longitude and latitude variables defined above. I sampled 300 records, changed the name to the **non-scientific** genus *Gigantopithecus*, and then selected only the name, longitude and latitude columns. The `sample` function is affected by `setseed`.

**Note:** the file paths assume that you have a `data` folder at the same level as your `Rproj` folder, and that the csv files are in that folder, per previous instructions.

```{r}
# Bigfoot data ------------------------------------------------------------

bigfoot <- read_csv("data/bigfoot.csv")

bigfoot <- filter(bigfoot,
                  long >= min_long & long <= max_long,
                  lat >= min_lat & lat <= max_lat) %>% 
  sample_n(300) %>% 
  mutate(name = "Gigantopithecus") %>% 
  select(name, long, lat)

```

Next, read in the `bears.csv` data. I previously wrangled the data so it has only the lontitude and latitude in the range defined above.

```{r}
# Bear data ---------------------------------------------------------------

bears <- read_csv("data/bears.csv")

both_species <- bind_rows(bigfoot, bears)

head(both_species)
tail(both_species)
```

This code gets the terrain map from [Stamen Maps](http://maps.stamen.com/#watercolor/12/37.7706/-122.3782) (similar to Google Maps but does not require registration). This will take a few minutes. `zoom` defines the resolution. The higher the value, the greater the resolution. Whenever you use this technique, always start with a lower value like 3 or 4. Use a higher value like 7 when you make your final figure. (The actual final value depends on how large of a geographic area that you need to cover.)

```{r}
base = get_stamenmap(bbox = c(min_long, 
                              min_lat, 
                              max_long, 
                              max_lat),
                     zoom = 4, 
                     maptype = "terrain-background")



ggmap(base)
```

Dark green shows forested areas. The grayer colors show higher elevations.

`ggmap` uses `ggplot2` to plot this layer, so we can store the result into an object and add to it using familiar geoms. The first layer to add is the Bigfoot data.

```{r}
base <- ggmap(base)

base + geom_point(data = bigfoot,
                  aes(x = long,
                      y = lat))
```

Bigfoot clearly seems to prefer the forested areas, especially around Seattle. In case you are wondering, most sightings of Bigfoot were recorded before marijuana was legalized in Washington state. 

What about black bears?

```{r}
base + geom_point(data = bears,
                  aes(x = long,
                      y = lat))

```

Black bears also seem to prefer the woods. Hmmm.... The final plot includes both species, from the `species` data frame. I used `scale_shape_manual` to choose fillable shapes. The shapes and fill color are matched by the `aes` aesthetic to each species. I ensured only a single legend was used by setting both shape and color to "Species" in the `labs` layer. I increased the point size slightly, outsize of `aes`.

```{r}
base + geom_point(data = both_species,
                  aes(x = long,
                      y = lat,
                      shape = name,
                      fill = name),
                  size = 2) +
  scale_shape_manual(values = c(22:23)) +
  labs(x = "Longitude",
       y = "Latitude",
       fill = "Species",
       shape = "Species")
```

### Distribution map: your turn

Recreate the Bigfoot and Black Bear distribution map but change the `setseed` number to your last seven digits of your S0 number. The seed determines the random sample of Bigfoot sightings but the bear distribution should not change.


## Part 3: Bathymetry

<!--
Future link for bathymetry vs topography definition. Govt was shutdown at the time this doc was assembled.
https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=19&cad=rja&uact=8&ved=2ahUKEwj-nMe01ODfAhUE7IMKHRGxCk0QFjASegQIARAB&url=http%3A%2F%2Foceanexplorer.noaa.gov%2Ffacts%2Fmaps.html&usg=AOvVaw1Gt_kI8Y1nD2dab3g_rWqs
-->
[Bathymetric maps](https://en.wikipedia.org/wiki/Bathymetric_chart) are maps that show the changes of depth in a body of water. We will use bathymetry in combination with dot distribution maps. For this example, we will plot the distribution of earthquakes near the island nation of [Fiji.](https://www.fiji.travel)

### Example: Fiji earthquakes

Fiji is a group of islands located on the western edge of the [Pacific Plate.](https://en.wikipedia.org/wiki/Pacific_Plate). The edges of  the Pacific plate has lots of [seismic activity,](https://en.wikipedia.org/wiki/Ring_of_Fire) in the form of volcanos and  earthquakes.  Earthquakes that have occurred around Fiji since 1964 are recorded in the `quakes` data set, one of the data sets included with R. The `quakes` data set include longitude, latitude, magnitude (strength), and depth.

**The amount of data needed to plot bathymetry is large, so some plots will take several seconds to draw.**

This part uses the `tidyverse` and `marmap` libraries. If you loaded them for Part 1, you do not need to load them now unless you quit previously and have returned to finish.

```{r eval=FALSE}
library(tidyverse)
library(marmap)
```

As above, I defined global variables with the longitude and latitude range for the map. The bathymetric data has depth in feet but the `quakes` data has depths in kilometers, so I converted quake depth to feet.

```{r}
min_long <- -170
max_long <- 164
min_lat  <- -42
max_lat  <- -8

# This converts depth in km to depth in feet.
# Necessary because bathymetry data will be in feet
earthquakes <- quakes %>% 
   mutate(depth = depth * 3280.84)
```

This chunk obtains the data directly from NOAA. The `getNOAA.bathy` function retrieves the data from a NOAA website. The `antimeridian = TRUE` argument is necessary here because Fiji sits on the 180° [meridian](https://en.wikipedia.org/wiki/180th_meridian) where the longitude changes from East to West. The `keep = TRUE` argument causes the function to save the data to a local csv file. In the future, when you run the code, the function will load the data from the file rather than download it again. If you delete the file, the data will be downloaded and saved again.

```{r}
# Will auto read the saved file if present.

fiji <- getNOAA.bathy(lon1 = min_long,
                      lon2 = max_long,
                      lat1 = min_lat,
                      lat2 = max_lat,
                      antimeridian = TRUE,
                      keep = TRUE)

```

The `marmap` package includes an `autoplot.bathy()` function to automatically plot bathymetric data with ggplot2, using reasonable default settings. The `geom = c("raster", "contour")` tells `ggplot` to use `geom_raster` and `geom_contour`. The `size = 0.1` argument specifies the thickness of the contour lines. Try tweaking this value a little to see how changes affect the appearance of the plot.

Ignore the warning about ignoring the `size` parameter. It is not actually ignored.

```{r}
# Could also just use autoplot() without the .bathy extension.
autoplot.bathy(fiji, 
         geom = c("raster", "contour"),
         size = 0.1,
         na.rm = TRUE)

```

Very oceanic. I thought the default color gradient was too dark so I used a custom gradient by adding a `scale_fill_gradient2` layer. The `low` color is used for the greatest depths. I also labeled the x- and y- axes. **Note:** I used `theme(axis.title.y = ...)` to rotate the y-axis label. `vjust = 0.5` centers the label vertically on the axis. 

```{r}
# Using autoplot, which "knows" to use autoplot.bathy
autoplot(fiji, 
         geom = c("raster","contour"),
         size = 0.1,
         na.rm = TRUE) +
  scale_fill_gradient2(low = "dodgerblue4", 
                       mid = "gainsboro", 
                       high = "darkgreen",
                       name = "Depth (ft)") +
  labs(x = "Longitude",
       y = "Latitude") +
  theme(axis.title.y = element_text(angle = 0, 
                                    vjust = 0.5))

```

That's a good start. I saved the `autoplot` result to an object called `base_map`, and then add the Fiji earthquakes data using familiar `ggplot` layers. I used `geom_point` to plot the location of each seismic event.

```{r}
base_map <- autoplot(fiji, 
                     geom = c("raster","contour"),
                     size = 0.1,
                     na.rm = TRUE) +
  scale_fill_gradient2(low = "dodgerblue4", 
                       mid = "gainsboro", 
                       high = "darkgreen",
                       name = "Depth (ft)") +
  labs(x = "Longitude",
       y = "Latitude") +
  theme(axis.title.y = element_text(angle = 0, 
                                    vjust = 0.5))

base_map + 
  geom_point(data = earthquakes,
             aes(x = long,
                 y = lat))
```

That's a lot of earthquakes. The points are rather crowded. I also want to adjust the size of the points to reflect the magnitude of the each quake. I used the `alpha` argument to make the points more transparent.


```{r}
base_map + 
  geom_point(data = earthquakes,
             aes(x = long,
                 y = lat,
                 size = mag),
             alpha = 0.4)
```

Hmm. I thought the points were too large, but I still wanted the point size to reflect magnitude. I used the `scale_size_continuous` layer to set the minimum and maximum point sizes used for magnitude. I added the `name` argument to name this legend.

```{r}
base_map + 
  geom_point(data = earthquakes,
             aes(x = long,
                 y = lat,
                 size = mag),
             alpha = 0.4) +
  scale_size_continuous(range = c(0.5,3), name = "Magnitude")
```

That's better. It's easy to see where the concentration of earthquakes is highest, without overwhelming the plot.

**Stage, commit, push.**

### Bathymetry: now you try it

```{r include=FALSE}
knitr::opts_chunk$set(include = FALSE, eval = TRUE, echo=FALSE, message=FALSE)
```

- This part uses the `tidyverse` and `marmap` libraries. You do not need to load them unless you quit and have returned to finish up the assignment.

```{r eval=FALSE}
library(tidyverse)
library(marmap)
```

- Set the following global variables:
    - `min_long`: -90
    - `max_long`: -58
    - `min_lat`: 8
    - `max_lat`: 28

```{r}
# Global Vars -------------------------------------------------------------

min_long    <- -90
max_long    <- -58
min_lat     <-   8
max_lat     <-  28
resolution  <-   4  # Use 1 for final fig and highest resolution

```

Load `blennies.csv` into a `blennies` object. Use `getNOAA.bathy()` function like we did in the Fiji earthquakes example to get the bathymetric data for the Caribbean Sea.

- Set `antimeridian` to FALSE.

- Set `keep = TRUE` to that the data are saved after the first run.

- Save the results to a `carib_sea` object.

```{r}
blennies <- read_csv("data/blennies.csv")

carib_sea <- getNOAA.bathy(lon1 = min_long, 
                           lon2 = max_long, 
                           lat1 = min_lat, 
                           lat2 = max_lat, 
                           keep = TRUE)

```

Use `autoplot` to plot the base bathymetric map. Add a `labs()` layer to label the x- and y- axes as "Longitude" and "Latitude", respectively. Replace the `scale_fill_gradient2` layer with this layer.

```
scale_fill_etopo(guide = FALSE)
```

Once you are happy with the results, save the base map to a `base_map` object.

```{r}
# Ignore the warning from autoplot regarding color and size.
# They get used by geom_contour()

base_map <- autoplot(carib_sea, 
                     geom = c("r", "c"), 
                     size = 0.1) + 
  scale_fill_etopo(guide = FALSE) +
  labs(x = "Longitude",
       y = "Latitude")

```

### Add the blennies

Add a point layer to show the distribution of the blennies, with these parameters.

- Map shape to name in the aesthetics layer.
- Use fillable shapes 21-23.
- Specify a color for the fill. I used white. You can use other colors but be sure the colors contrast well with the background.
- Increase the point size a bit. Try a range between 2-4. You can use decimal point sizes, like 2.8 or 3.1. Find a value that you think helps the points to stand out without overwhelming the plot. 

    **Note:** for the best sense of the final point size, click on the small "Show in New Window" button just above the top right of the plot in your notebook. The points tend to look a little large in the small plots in your notebook.

- Change the legend name to "Species".
- Add `theme(legend.position = "bottom")` to put the legend below the map.
- Figure out how to add a theme element to italicize the species names in the legend.

Your final plot should look like this, although your point size and fill colors may vary.

```{r include=TRUE}
base_map +  
  geom_point(data = blennies, 
             aes(x = long, 
                 y = lat,
                 shape = name),
             fill = "white",
             size = 3) +
  scale_shape_manual(values = c(21, 22, 23),
                     name = "Species") +
  theme(legend.position = "bottom",
        legend.text = element_text(face = "italic"))

```


**Stage, commit, push.**

## Full code for the Fiji Quakes

**This is for reference only. You do not have to run this code.**

This code builds the Fiji earthquakes plot from scratch using `ggplot2`. The `autoplot()` function of `marmap` works well but building the map up by individual layers gives you more control of the details.

The bathymetry data must be converted to a dataframe object, which is done here using `fortify`, a function in `ggplot2`. In this case, `fortify` creates an `x` column with longitude, a `y` column with latitude, and a `z` column with depth. Depth values are negative to show depth below the surface (z = 0).

```{r eval=TRUE, include=TRUE, echo=TRUE}
fiji <- getNOAA.bathy(lon1 = -170,
                      lon2 = 164,
                      lat1 = -42,
                      lat2 = -8,
                      antimeridian = TRUE,
                      keep = TRUE)

# Convert the bathymetry data to a data frame.
fiji_df = fortify(fiji)

ggplot(fiji_df,
       aes(x = x,
           y = y,
           z = z,
           fill = z)) + 
  geom_tile() +
  geom_contour(data = NULL, lwd = 0.1, color = "gray30") +
  geom_contour(colour = "black", 
               linetype = "solid", 
               size = 0.3, 
               breaks = 0, alpha = 1) +
  scale_fill_gradient2(low = "dodgerblue4", 
                       mid = "gainsboro", 
                       high = "darkgreen", name = "Depth") +
  geom_point(data = earthquakes,
             inherit.aes = FALSE,
             aes(x = long,
                 y = lat,
                 size = mag),
             alpha = 0.4) +
  coord_quickmap() +
  theme_minimal() +
  scale_size_continuous(range = c(0.5,3)) +
  labs(size = "Magnitude", 
       color = "Magnitude",
       x = "Longitude",
       y = "Latitude")

```

***

*et Vóila*

